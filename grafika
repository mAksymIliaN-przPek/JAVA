// Napisz jak wyliczysz oÅ›wietlenie sciany w cieniowaniu pÅ‚askim
// Wyliczanie oÅ›wietlenia polega na uwzglÄ™dnieniu kierunku Å›wiatÅ‚a i normalnej powierzchni
//    okreÅ›lamy kierunek Å›wiatÅ‚a
//    obliczenie normalnej powierzchni - wektor jednostkowy prostopadÅ‚y do powierzchni trÃ³jkÄ…ta
//    oblicz wartoÅ›Ä‡ Å›wiatÅ‚a
//        wartoÅ›Ä‡_Å›wiatÅ‚a = dot(nmormalna, kierunek_Å›wiatÅ‚a)
//                          dot = iloczyn skalarny
 
// Zmodyfikuj algorytm rysowania linii tak, aby wykorzystywaÅ‚ tylko zmienne typu int
// public void drawlineBresenham(int x0, int x1, int y0, int y1){
//    int white = 255 | (255 << 8) | (255 < 16) | (255 << 24);
//    flat err = 0;
//    flat d = Math.abs(2*(y1-y2);
//    int y = y0;
//    for(int x = x0; x<x1; x++){
//        renderer.setRGB(x, y, white);
//        err +=d;
//        if(err > (x1-x0)){
//            y += (y1 > y0 ? 1 :- 1); // y +1; -> jak 1 to tylko w gÃ³re liniÄ™
//            err -= 2 * (x1-x0);
//        }
//    }
// }
 
// Offset i stride wwe floatach Vertex(xyz, rgb, st)xx3 na bajtach od 0 do 92:
//
//              Vertex 1                Vertex 2                Vertex 3
//      X Y Z | R G B | S T ||| X Y Z | R G B | S T ||| X Y Z | R G B | S T
//      0 4 8 12 16 20 24 28 32
// POSITION -> | od 0 do 32 Vertex 1 ----------------> stride 32
// COLOR offset 0  |
// COLOR offest 12 | od 12 do XYZ Vertex 2 -> stride 32
// TEXTURE offster 24 | od 24 do RGB Vertex 2 -> stride 32
 
// Zdefiniuj atrybuty danych znajdujÄ…cych siÄ™ w buforze wierzchoÅ‚kÃ³w (Vertex Buffer Object), aby odzwierciedliÄ‡
// uÅ‚oÅ¼enie danych jak na poniÅ¼szym diagramie
//              Vertex 1                Vertex 2                Vertex 3
//      X Y Z | R G B | S T ||| X Y Z | R G B | S T ||| X Y Z | R G B | S T
//      0 4 8 12 16 20 24 28 32
// uÅ¼yj funkcji glVertexAttribPointer. Jej deklaracja wyglÄ…da nastÄ™pujÄ…co:
// void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
//
// glVertexAttribPointer(0, 12, GL.Float, GL.False, 32, (void)*0);
// glVertexAttribPointer(1, 8, GL.Float, GL.False, 32, (void)*12);
// glVertexAttribPointer(2,             12,             GL.Float,           GL.False,               32,                 (void)*20);
//                index of vertex   iloÅ›Ä‡ atrybutÃ³w    typ danych       czy powinien byÄ‡         ile zajmuje vertex
//                                    komponentÃ³w                   normalizowany (dla float z
//                                                                  nie ma efektu i tak)
 
// UzupeÅ‚nij poniÅ¼szy shader wierzchoÅ‚kowo, tak aby korzystaÅ‚ z danych w buforze zdefiniowanym w zadaniu 1.
// Kolor i poÅ‚oÅ¼enie powinny byÄ‡ przekazywane dalej do potoku graficznego (zmienne wyjÅ›ciowe)
// natomiast poÅ‚oÅ¼enie wierzchoÅ‚ka powinno byÄ‡ rozszerzone do wektora 4-elementowego
// (ostatni element ustaw na 1.0) i wykorzystywane do ustawienia zmiennej gl = Poistion
//
// layout(location = 0) in Vec3 aPos;       // aPos
// layout(location = 1) in Vec3 aColor;     // zmienne wejÅ›ciowe
// layout(location = 2) in Vec2 aTexCoord;  // aTexCoord
//
// FrayColor = vec4(1.0f, 0.5f, 0.2f, 1.0f) // dodaj def. danych wejÅ›ciowych
//
// void main(){
//      gl.Position = vec4(aPos.x, aPos.y, aPos.z, 1) // ustaw wartoÅ›ci
// }
 
// Rodzaje shadera w OpenGL:
// Vertex Shader
// Geometry Shader
// Fragment Shadedr, Pixel Shader
 
// Czy nastÄ™pujÄ…ce zadanie jest prawdziwe?
// W cieniowaniu pÅ‚askim kaÅ¼dy piksel danej Å›ciany ma indywidualnie wyliczane parametry oÅ›wietlenia?
// FAÅSZ
// nie dla kaÅ¼dego piksela; jedna Å›ciana bÄ™dzie miaÅ‚a wszystkie piksele takie same
 
// Czy Å›wiatÅ‚o padajÄ…ce na Å›ciane obiektu bÄ™dzie miaÅ‚o te same parametry w cieniowaniu pÅ‚askim?
// TAK
 
// Uniform czy zmienna jest unikalna dla kaÅ¼dego shadera
// TAK
 
// JeÅ›li punkt p ma jednÄ… wspÃ³Å‚rzÄ™dnÄ… barycentrycznÄ… rÃ³wnÄ… -0.05, a pozostaÅ‚e majÄ… wartoÅ›Ä‡ w przedziale (0,1) to leÅ¼y on
// POZA TRÃ“JKÄ„TEM
//
// - wszystkie wspÃ³Å‚rzÄ™dne (alfa, beta, gamma) naleÅ¼Ä…ce do przedziaÅ‚u (0,1) to leÅ¼y on WEWNÄ„TRZ trÃ³jkÄ…ta
// - jedna wspÃ³Å‚rzÄ™dna rÃ³wna 0, pozostaÅ‚e w przedziale (0,1) to leÅ¼y on NA BOKU trÃ³jkÄ…ta
// - dwie wspÃ³Å‚rzÄ™dne rÃ³wne 0, jedna rÃ³wna 1 to leÅ¼y on W WIERZCHOÅKU
// - w przeciwnych wypadkach leÅ¼y POZA
 
// Opisz jak dziaÅ‚a algorytm backface culling
// Algorytm sprawdza czy dana Å›ciana zwrÃ³cona jest w stronÄ™ kamery.
// Sprawdza, czy promieÅ„ kierunku patrzenia pada na Å›cianÄ™, jeÅ›li nie pada nie jest ona renderowana
// jeÅ›li w nawet najmniejszym stopniu pada jest ona renderowana.
 
// UzupeÅ‚nij zawartoÅ›Ä‡ instrukcji warunkowej, tak aby sprawdzaÅ‚a ona czy wspÃ³Å‚rzÄ™dnÄ™ barycentryczne bar sÄ… w przedziale (0,1)
//
// bar zawiera trzy pola: x,y,z
//
// public void drawTriangle(Vec2f A, Vec2f B, Vec2f C){
//      int white = 255 | (255 << 8) | (255 < 16) | (255 << 24);
//      for (int x = 0; x < w; x++) {
//          Vec2f P = new Vec2f(x,y);
//          Vec3f bar = barycentric(A,B,C,P);
//          if (bar.x > 0 && bar.x < 1 && bar.y > 0 && bar.y < 1 & bar.z > 0 & bar.z < 1) {
//              render.setRGB(x, y, white);
//          }
//      }
// }




Pytanie 1 
MoÅ¼esz uÅ¼ywaÄ‡ symboli: -> x ^ âˆˆ {} () 
PrzykÅ‚adowo:       f: X -> Y 
 
8-bitowy jednokanaÅ‚owy obraz cyfrowy o rozmiarach HxW moÅ¼na zdefiniowaÄ‡ jako funkcjÄ™: 
ODP: f: {x âˆˆ (0, W-1)} x {Y âˆˆ (0, H-1)} -> [0, 255] 
 
 
Pytanie 2 
public void drawLineBresenhamInt(int x0, int y0, int x1, int y1) { 
int white = 255 | (255 << 8) | (255 << 16) | (255 << 24); 
int err = 0; 
... 
int y = y0; 
for(int x = x0; x < x1; x++) { 
    		render.setRGB(x, y, white); 
    		err += d; 
    		if (err > (x1-x0)) { 
        			y += 1; 
        			err -= 2*(x1-x0); 
  		} 
} 
} 
 
KtÃ³ra wersja 4 linijki jest poprawna dla caÅ‚kowitoliczbowego algorytmu rysowania linii Bresenhama? 
ODP: int d = 2 * (y1 - y0); 
 
 
Pytanie 3 
DokoÅ„cz zdanie: 
Algorytmy rasteryzacji transformujÄ… .................. . 
ODP: pÅ‚aszczyzny 2d w siatkÄ™ rastrowÄ… 
 
 
Pytanie 4 
JeÅ›li wartoÅ›Ä‡ w z-buforze o danych wspÃ³Å‚rzÄ™dnych (x,y) jest ............... niÅ¼ przetwarzanego piksela, to framebuffer nie jest aktualizowany. 
PodpowiedÅº: oÅ› -Z jest skierowana za ekran. 
ODP: mniejsza 
 
 
Pytanie 5 
Podaj przykÅ‚ad przestrzeni kolorÃ³w (inny niÅ¼ RGB) wykorzystywany czÄ™sto w urzÄ…dzeniach druku kolorowego: 
ODP: CMYK 
 
 
Pytanie 6 
Co jest prawdÄ… o renderowaniu przez rasteryzacjÄ™ obiekt po obiekcie? 
A) Jest wolne. 
B) DziaÅ‚a jako potok przetwarzania. 
C) kolejnoÅ›Ä‡ to piksel po pikselu 
D) DziaÅ‚a na CPU. 
E) DziaÅ‚a na GPU. 
F) Idealne do zastosowaÅ„ real-time. 
ODP: B, E, F 
 
 
Pytanie 7 
Najbardziej efektywnym algorytmem eliminacji powierzchni zasÅ‚oniÄ™tych jest ...................... . 
ODP: algorytm z-bufora 
 
 
Pytanie 8 
WiÄ™kszoÅ›Ä‡ urzÄ…dzeÅ„ do prezentacji grafiki to urzÄ…dzenia: 
A) rastrowe 
B) wektorowe 
C) Å¼adne z wymienionych 
ODP: A) rastrowe 
 
 
Pytanie 9 
NajczÄ™Å›ciej wykorzystywanym modelem kamery w grafice komputerowej jest ...................... . 
ODP: kamera otworkowa 
 
 
Pytanie 10 
Translacja 2D moÅ¼e byÄ‡ reprezentowana mnoÅ¼eniem macierzy o wymiarach ....... x ....... . 
ODP: 3x3 
 
 
Pytanie 11 
Jakie wspÃ³Å‚rzÄ™dne sÄ… rezultatem transformacji viewport? 
ODP: wspÃ³Å‚rzÄ™dne ekranu 
 
 
Pytanie 12 
W transformacji perspektywicznej rozmiar obiektu na obrazie jest ...................... . 
ODP: zaleÅ¼ny od odlegÅ‚oÅ›ci od kamery, im dalej obiekt znajduje siÄ™ od kamery, tym mniejszy siÄ™ wydaje 
 
 
Pytanie 13 
WymieÅ„ programowalne etapy potoku graficznego: 
ODP: etap przetwarzania geometrii, etap przetwarzania pikseli 
 
 
Pytanie 14 
public void drawLineBresenhamInt(int x0, int y0, int x1, int y1) { 
int white = 255 | (255 << 8) | (255 << 16) | (255 << 24); 
float err = 0.0f; 
float d = (float)(y1 - y0) / (x1 - x0); 
int y = y0; 
for(int x = x0; x < x1; x++) { 
render.setRGB(x, y, white); 
err += d; 
if (err > 0.5) { 
y += 1; 
err -= 1.0f; 
} 
} 
} 
 
Czy powyÅ¼szym algorytmem moÅ¼na narysowaÄ‡ poprawnie nastÄ™pujÄ…cÄ… liniÄ™ (pixel p0 zaznaczony na niebiesko)? 
ODP: tak lub nie 
Tu trzeba patrzeÄ‡ w kodzie jaki znak stoi przy zmiennej y. JeÅ›li y+=1 to algorytm narysuje liniÄ™ do gÃ³ry. JeÅ›li y-=1 to algorytm narysuje liniÄ™ w dÃ³Å‚. JeÅ›li nie bÄ™dzie tam dodawania ani odejmowania to linia bÄ™dzie pozioma. 
 
 
Pytanie 15 
Czy nastÄ™pujÄ…ce zdanie jest prawdziwe?: 
W cieniowaniu pÅ‚askim kaÅ¼dy piksel danej Å›ciany ma indywidualnie wyliczane parametry oÅ›wietlenia. 
ODP: nie 
 
 
Pytanie 16 
Macierz transformacji trÃ³jwymiarowego wektora [4, 2, 2] do wektora [8, 6, 1] bÄ™dzie wyglÄ…daÄ‡ nastÄ™pujÄ…co: 
 
ODP: 2, 0, 0, 0, 3, 0, 0, 0, 0.5 
 
 
Pytanie 17 
Model opisujÄ…cy coÅ›, co ma pojawiÄ‡ siÄ™ na obrazie to: 
A) model matematyczny 
B) model obliczeniowy 
C) model geometryczny 
ODP: C) model geometryczny 
 
 
Pytanie 18 
....................... i ....................... pozwalajÄ… GPU uzyskaÄ‡ wysokÄ… wydajnoÅ›Ä‡. 
ODP: potokowoÅ›Ä‡ i zrÃ³wnoleglenie 
 
 
Pytanie 19 
JeÅ›li punkt ğ‘ ma jednÄ… wspÃ³Å‚rzÄ™dnÄ… barycentrycznÄ… rÃ³wnÄ… 0.1, a pozostaÅ‚e majÄ… wartoÅ›Ä‡ w przedziale (0,1), to leÅ¼y on .................................. . 
ODP: wewnÄ…trz trÃ³jkÄ…ta 
 
 
Pytanie 20 
Podaj co jest wejÅ›ciem a co wyjÅ›ciem transformacji kamery. 
ODP: wejÅ›cie: wspÃ³Å‚rzÄ™dne punktÃ³w w przestrzeni sceny (world coordinates) 
wyjÅ›cie: wspÃ³Å‚rzÄ™dne punktÃ³w w przestrzeni kamery (camera coordinates) 
 
 
Pytanie 21 
DokoÅ„cz zdanie: 
Algorytmy rasteryzacji transformujÄ… .................. . 
ODP: obiekty geometryczne w piksele 
 
 
Pytanie 22 
Wynikiem jakiej transformacji jest geometria we wspÃ³Å‚rzÄ™dnych ekranu? 
ODP: transformacji viewport 
 
 
Pytanie 23 
Opisz krÃ³tko, czym jest kanoniczna bryÅ‚a widzenia i podaj jaki typ bryÅ‚y wystÄ™puje dla projekcji perspektywicznej. 
ODP: jest to szeÅ›cian 2x2x2 ze Å›rodkiem w poczÄ…tku ukÅ‚adu, dla projekcji perspektywicznej typ bryÅ‚y to ostrosÅ‚up Å›ciÄ™ty 
 
 
Pytanie 24 
     Vertex 1           Vertex 2           Vertex 3          
X Y Z S T R G B X Y Z S T R G B X Y Z S T R G B 
ZakÅ‚adajÄ…c, Å¼e dane w buforze sÄ… typu FLOAT i zorganizowane sÄ… jak na rysunku, podaj w bajtach offset i stride poszczegÃ³lnych atrybutÃ³w wierzchoÅ‚ka: 
ODP: 1 â€“ stride: 32, offset: 0 
2 â€“ stride: 32, offset: 12 
3 â€“ stride: 32, offset: 20 
 
 
Pytanie 25 
Napisz instrukcje warunkowÄ… w pseudokodzie, czy punkt jest wewnÄ…trz trÃ³jkÄ…ta. 
ODP: if (p.x > 0 && p.x < 1 && p.y > 0 && p.y < 1 && p.z > 0 && p.z < 1) { // narysuj } 
 
 
Pytanie 26 
Czy Å›wiatÅ‚o padajÄ…ce na Å›cianÄ™ obiektu bÄ™dzie miaÅ‚o te same parametry w cieniowaniu pÅ‚askim? 
ODP: tak 
> cieniowanie pÅ‚askie - jedno obliczenie na jednÄ… Å›cianÄ™ 
> cieniowanie Gourarda - obliczenia na kaÅ¼dy wierzchoÅ‚ek  
> cieniowanie Phonga - obliczenia wymagane sÄ… dla kaÅ¼dego piksela obrazu 
 
 
Pytanie 27 
JeÅ¼eli wartoÅ›Ä‡ w z-buforze o danych wspÃ³Å‚rzÄ™dnych (x,y) jest ....... niÅ¼ przetwarzanego piksela, to framebuffer nie jest aktualizowany. 
ODP: mniejsza 
 
 
Pytanie 28 
Z czego skÅ‚ada siÄ™ kamera? 
ODP: e â€“ punkt poÅ‚oÅ¼enia 
g â€“ wektor kierunku patrzenia 
t â€“ wektor view-up 
 
 
Pytanie 29 
WymieÅ„ rodzaje shaderÃ³w w OpenGL. 
ODP: Vertex Shader: Transformacje wierzchoÅ‚kÃ³w. 
Fragment Shader: Kolorowanie pikseli. 
Geometry Shader: Modyfikacja prymitywÃ³w. 
Tessellation Control Shader: Kontrola podziaÅ‚u prymitywÃ³w. 
Tessellation Evaluation Shader: Ocena nowych wierzchoÅ‚kÃ³w. 
Compute Shader: OgÃ³lne zadania obliczeniowe. 
 
 
Pytanie 30 
Czy nastÄ™pujÄ…ce zdanie jest prawdziwe? 
Zmienna typu uniform jest unikalna dla kaÅ¼dego programu shadera i moÅ¼e byÄ‡ dostÄ™pna z dowolnego shadera na dowolny etapie potoku graficznego. 
ODP: tak 
 
 
Pytanie 31 
Podaj sekwencjÄ™ mnoÅ¼enia macierzy, aby uzyskaÄ‡ macierz dokonujÄ…ca transformacji wspÃ³Å‚rzÄ™dnych wirtualnego Å›wiata 3D do wspÃ³Å‚rzÄ™dnych ekranu: 
M = ............... 
ODP: M = M_vp * M_per * M_cam 
 
 
Pytanie 32 
Punkt P ma nastÄ™pujÄ…ce wspÃ³Å‚rzÄ™dne barycentryczne wzglÄ™dem pewnego trÃ³jkÄ…ta ABC: 0.62, 0.59, -0.22. Punkt P leÅ¼y (zaznacz wÅ‚aÅ›ciwÄ… odpowiedÅº): 
ODP: poza trÃ³jkÄ…tem 
 
 
Pytanie 33 
Czy nastÄ™pujÄ…ce zdanie jest prawdziwe? 
Zmienna typu uniform jest unikalna dla kaÅ¼dego programu shadera i moÅ¼e byÄ‡ dostÄ™pna z dowolnego shadera na dowolny etapie potoku graficznego. 
ODP: tak 
 
 
Pytanie 34 
WymieÅ„ 3 wÅ‚asnoÅ›ci obrazu i ich przykÅ‚adowe wartoÅ›ci: 
ODP: Liczba kanaÅ‚Ã³w: 1 (czarno-biaÅ‚y), 3 (kolorowy RGB), 4 (kolorowy RGB z przezroczystoÅ›ciÄ…) 
GÅ‚Ä™bia kolorÃ³w: 16 bitÃ³w na piksel 
RozdzielczoÅ›Ä‡: 1920x1080 px (FHD) 
 
 
Pytanie 35 
Podaj dwa przykÅ‚ady transformacji liniowych, 
ODP: skalowanie, odbicie 
 
 
Pytanie 36 
Translacja 3D moÅ¼e byÄ‡ reprezentowana mnoÅ¼eniem macierzy o wymiarach â€¦â€¦. x â€¦â€¦. . 
ODP: 4x4 
 
 
Pytanie 37 
Podaj ogÃ³lny algorytm ray-castingu, 
ODP: 1. Wyprowadzenie promienia kamery w kierunku rzutni. 
2. Znalezienie punktu ktÃ³ry przecina siÄ™ jako pierwszy z obiektem ze sceny. 
3. Ustalenie jasnoÅ›ci punktu. 
 
 
Pytanie 38 
Jakie wspÃ³Å‚rzÄ™dne sÄ… rezultatem transformacji kamery? 
ODP: kanoniczna bryÅ‚a widzenia, wspÃ³Å‚rzÄ™dne w przestrzeni kamery 
 
 
Pytanie 39 
Translacja jest przykÅ‚adem transformacji ....... 
ODP: nieliniowej 
 
 
Pytanie 40 
Kamera umieszczona jest ....... wirtualnÄ… pÅ‚aszczyznÄ… obrazu. 
ODP: za 
 
 
Pytanie 41 
Operacja pozwalajÄ…ca przedstawiÄ‡ obiekty trÃ³jwymiarowego Å›wiata na pÅ‚aszczyÅºnie to: 
ODP: rzutowanie 
 
 
Pytanie 42 
Napisz pseudokod do barycentric 
ODP:  
public Vec3f barycentric(Vec3f A, Vec3f B, Vec3f C, Vec3f P) { 
      // wektor skÅ‚adajÄ…cy siÄ™ ze wspÃ³Å‚rzÄ™dnych x wektorÃ³w AB, AC, PA 
      Vec3f v1 = new Vec3f(B.x - A.x, C.x - A.x, A.x - P.x); 
 
      // wektor skÅ‚adajÄ…cy siÄ™ ze wspÃ³Å‚rzÄ™dnych y wektorÃ³w AB, AC, PA 
      Vec3f v2 = new Vec3f(B.y - A.y, C.y - A.y, A.y - P.y); 
 
      // iloczyn skalarny v1 i v2 
      Vec3f cross = this.scalarDot(v1, v2); 
 
      // wektor postaci: cross.x / cross.z, cross.y / cross.z 
      Vec2f uv = new Vec2f(cross.x / cross.z, cross.y / cross.z); 
 
      // wspÃ³Å‚rzÄ™dne barycentryczne, uv.x, uv.y, 1- uv.x - uv.y 
      Vec3f barycentric = new Vec3f(uv.x, uv.y, 1 - uv.x - uv.y); 
 
      return barycentric; 
} 
 
 
Pytanie 43 
Opisz czym jest fragment i na jakim etapie potoku graficznego powstaje. 
ODP: Fragment to kandydat na bycie pikselem, jest to dyskretna wspÃ³Å‚rzÄ™dna ekranu, ktÃ³ra potem stanie siÄ™ pikselem. Wiele fragmentÃ³w moÅ¼e zajmowaÄ‡ tÄ… samÄ… wspÃ³Å‚rzÄ™dnÄ…. Powstaje w procesie rasteryzacji z rzeczywistych wspÃ³Å‚rzÄ™dnych wielokÄ…ta. 
 
 
Pytanie 44 
JakÄ… wartoÅ›ciÄ… powinna byÄ‡ zainicjalizowana komÃ³rka z-buffora? 
ODP: Maksymalna wartoÅ›Ä‡ `z` z danej sceny. Zmienna `z` to gÅ‚Ä™bokoÅ›Ä‡. 
 
 
Pytanie 45 
WymieÅ„ 3 cechy rzutowania ortograficznego. 
ODP: 1. Zachowuje rÃ³wnolegÅ‚oÅ›Ä‡ linii. 
2. Dystans od kamery nie wpÅ‚ywa na wielkoÅ›Ä‡ obiektu. 
3. Nie odzwierciedla sposobu w jaki ludzkie oko postrzega obraz. 
